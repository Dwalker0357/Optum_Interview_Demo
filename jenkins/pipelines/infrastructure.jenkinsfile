pipeline {
    agent any
    
    parameters {
        choice(
            choices: ['demo', 'full'],
            description: 'Deployment mode - demo for testing, full for production',
            name: 'INSTANCE_SIZE'
        )
        choice(
            choices: ['dev', 'prod', 'staging'],
            description: 'Environment to deploy to',
            name: 'ENVIRONMENT'
        )
        choice(
            choices: ['eu-west-1', 'us-east-1', 'ap-southeast-1'],
            description: 'AWS region for deployment',
            name: 'REGION'
        )
        booleanParam(
            defaultValue: false,
            description: 'Destroy infrastructure instead of creating it',
            name: 'DESTROY'
        )
    }
    
    environment {
        AWS_DEFAULT_REGION = "${params.REGION}"
        TF_VAR_environment = "${params.ENVIRONMENT}"
        TF_VAR_primary_region = "${params.REGION}"
        TF_VAR_deployment_mode = "${params.INSTANCE_SIZE}"
        TF_VAR_owner = "admin"
        TF_VAR_key_pair_name = "optum-demo-key"
        TERRAFORM_ROLE = "${params.ENVIRONMENT}-terraform-role"
    }
    
    stages {
        stage('Checkout') {
            steps {
                echo "Checking out code..."
                checkout scm
            }
        }
        
        stage('Print Parameters') {
            steps {
                echo "Parameters received:"
                echo "INSTANCE_SIZE: ${params.INSTANCE_SIZE}"
                echo "ENVIRONMENT: ${params.ENVIRONMENT}"
                echo "REGION: ${params.REGION}"
                echo "DESTROY: ${params.DESTROY}"
                echo ""
                echo "Environment variables:"
                echo "TF_VAR_deployment_mode: ${env.TF_VAR_deployment_mode}"
                echo "TF_VAR_environment: ${env.TF_VAR_environment}"
                echo "TF_VAR_primary_region: ${env.TF_VAR_primary_region}"
            }
        }
        
        stage('Bootstrap Backend') {
            steps {
                sh '''
                    # Use shared Jenkins role for S3 bucket and DynamoDB operations
                    aws s3 mb "s3://optum-${ENVIRONMENT}-demo-terraform-state" --region "${REGION}" 2>/dev/null || true
                    aws s3api put-bucket-versioning \
                        --bucket "optum-${ENVIRONMENT}-demo-terraform-state" \
                        --versioning-configuration Status=Enabled || true

                    # Create DynamoDB table for state locking
                    aws dynamodb create-table \
                        --table-name "optum-${ENVIRONMENT}-demo-tf-locks" \
                        --attribute-definitions AttributeName=LockID,AttributeType=S \
                        --key-schema AttributeName=LockID,KeyType=HASH \
                        --billing-mode PAY_PER_REQUEST \
                        --region "${REGION}" 2>/dev/null || true

                    # Wait until the table is ACTIVE (first time only)
                    aws dynamodb wait table-exists --table-name "optum-${ENVIRONMENT}-demo-tf-locks" --region "${REGION}"
                '''
            }
        }
        
        stage('Assume Terraform Role') {
            steps {
                script {
                    env.AWS_ACCOUNT_ID = sh(
                        script: 'aws sts get-caller-identity --query Account --output text',
                        returnStdout: true
                    ).trim()
                }
                sh '''
                    # Assume environment-specific terraform role
                    aws sts assume-role \
                        --role-arn "arn:aws:iam::${AWS_ACCOUNT_ID}:role/${TERRAFORM_ROLE}" \
                        --role-session-name jenkins-terraform-session \
                        --output json > /tmp/terraform-creds.json
                    
                    # Export temporary credentials
                    export AWS_ACCESS_KEY_ID=$(cat /tmp/terraform-creds.json | jq -r '.Credentials.AccessKeyId')
                    export AWS_SECRET_ACCESS_KEY=$(cat /tmp/terraform-creds.json | jq -r '.Credentials.SecretAccessKey')
                    export AWS_SESSION_TOKEN=$(cat /tmp/terraform-creds.json | jq -r '.Credentials.SessionToken')
                    
                    # Verify role assumption
                    aws sts get-caller-identity
                '''
            }
        }
        
        stage('Terraform Init') {
            steps {
                dir('terraform') {
                    sh '''
                        # Load terraform role credentials
                        export AWS_ACCESS_KEY_ID=$(cat /tmp/terraform-creds.json | jq -r '.Credentials.AccessKeyId')
                        export AWS_SECRET_ACCESS_KEY=$(cat /tmp/terraform-creds.json | jq -r '.Credentials.SecretAccessKey')
                        export AWS_SESSION_TOKEN=$(cat /tmp/terraform-creds.json | jq -r '.Credentials.SessionToken')
                        
                        # Remove existing terraform state to force backend reconfiguration
                        rm -rf .terraform
                        
                        terraform init -reconfigure \
                            -backend-config="bucket=optum-${ENVIRONMENT}-demo-terraform-state" \
                            -backend-config="key=${ENVIRONMENT}-demo/terraform.tfstate" \
                            -backend-config="region=${REGION}" \
                            -backend-config="dynamodb_table=optum-${ENVIRONMENT}-demo-tf-locks"
                    '''
                }
            }
        }
        
        stage('Terraform Plan') {
            when {
                expression { !params.DESTROY }
            }
            steps {
                dir('terraform') {
                    sh '''
                        # Load terraform role credentials
                        export AWS_ACCESS_KEY_ID=$(cat /tmp/terraform-creds.json | jq -r '.Credentials.AccessKeyId')
                        export AWS_SECRET_ACCESS_KEY=$(cat /tmp/terraform-creds.json | jq -r '.Credentials.SecretAccessKey')
                        export AWS_SESSION_TOKEN=$(cat /tmp/terraform-creds.json | jq -r '.Credentials.SessionToken')
                        
                        terraform plan \
                            -var="environment=${TF_VAR_environment}" \
                            -var="primary_region=${TF_VAR_primary_region}" \
                            -var="deployment_mode=${TF_VAR_deployment_mode}" \
                            -var="owner=${TF_VAR_owner}" \
                            -var="key_pair_name=${TF_VAR_key_pair_name}" \
                            -out=tfplan
                    '''
                }
            }
        }
        
        stage('Terraform Apply') {
            when {
                expression { !params.DESTROY }
            }
            steps {
                dir('terraform') {
                    sh '''
                        # Load terraform role credentials
                        export AWS_ACCESS_KEY_ID=$(cat /tmp/terraform-creds.json | jq -r '.Credentials.AccessKeyId')
                        export AWS_SECRET_ACCESS_KEY=$(cat /tmp/terraform-creds.json | jq -r '.Credentials.SecretAccessKey')
                        export AWS_SESSION_TOKEN=$(cat /tmp/terraform-creds.json | jq -r '.Credentials.SessionToken')
                        
                        terraform apply -auto-approve tfplan
                    '''
                }
            }
        }
        
        stage('Terraform Destroy') {
            when {
                expression { params.DESTROY }
            }
            steps {
                dir('terraform') {
                    sh '''
                        # Load terraform role credentials
                        export AWS_ACCESS_KEY_ID=$(cat /tmp/terraform-creds.json | jq -r '.Credentials.AccessKeyId')
                        export AWS_SECRET_ACCESS_KEY=$(cat /tmp/terraform-creds.json | jq -r '.Credentials.SecretAccessKey')
                        export AWS_SESSION_TOKEN=$(cat /tmp/terraform-creds.json | jq -r '.Credentials.SessionToken')
                        
                        terraform destroy -auto-approve \
                            -var="environment=${TF_VAR_environment}" \
                            -var="primary_region=${TF_VAR_primary_region}" \
                            -var="deployment_mode=${TF_VAR_deployment_mode}" \
                            -var="owner=${TF_VAR_owner}" \
                            -var="key_pair_name=${TF_VAR_key_pair_name}"
                    '''
                }
            }
        }
        
        stage('Output Results') {
            when {
                expression { !params.DESTROY }
            }
            steps {
                dir('terraform') {
                    sh 'terraform output -json > terraform_outputs.json'
                }
                archiveArtifacts artifacts: 'terraform/terraform_outputs.json', fingerprint: true
                
                script {
                    def outputs = readJSON file: 'terraform/terraform_outputs.json'
                    echo "Infrastructure deployment completed!"
                    echo "Check archived artifacts for detailed outputs."
                }
            }
        }
    }
    
    post {
        always {
            deleteDir()
        }
        success {
            echo "Pipeline completed successfully!"
        }
        failure {
            echo "Pipeline failed. Check logs for details."
        }
    }
}
